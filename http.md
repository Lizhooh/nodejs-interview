## http相关面试题

* [常见的HTTP相应状态码](#常见的HTTP相应状态码)
* [http的状态码中，499是什么?如何出现499，如何排查跟解决](#http的状态码中499是什么如何出现499如何排查跟解决)
* [http的缺点](#http的缺点)
* [http与https的区别](#http与https的区别)
* [什么是Http协议无状态协议?怎么解决Http协议无状态协议?](#什么是Http协议无状态协议怎么解决Http协议无状态协议)
* [URI和URL的区别](#URI和URL的区别)
* [常用的HTTP方法有哪些？](#常用的HTTP方法有哪些)
* [GET方法与POST方法的区别](#GET方法与POST方法的区别)
* [HTTP请求报文与响应报文格式](#HTTP请求报文与响应报文格式)
* [常见HTTP首部字段](#常见HTTP首部字段)
* [HTTP优化方案](#HTTP优化方案)
* [一次完整的HTTP请求所经历的7个步骤](#一次完整的HTTP请求所经历的7个步骤)
* [HTTP1.1版本新特性](#HTTP11版本新特性)
* [HTTP长连接、短连接](#HTTP长连接短连接)
* [为什么HTTP协议要基于TCP来实现？](#为什么HTTP协议要基于TCP来实现)
* [https工作原理](#https工作原理)
* [TCP的三次握手和四次挥手,两次握手可以吗？](#tcp的三次握手和四次挥手两次握手可以吗)
* [TCP和UDP的区别是什么？](#TCP和UDP的区别是什么)
* [SSL有几次握手？具体过程是怎样的？](#SSL有几次握手具体过程是怎样的)


### 常见的HTTP相应状态码

* 1xx：指示信息--表示请求已接收，继续处理
* 2xx：成功--表示请求已被成功接收、理解、接受
* 3xx：重定向--要完成请求必须进行更进一步的操作
* 4xx：客户端错误--请求有语法错误或请求无法实现
* 5xx：服务器端错误--服务器未能实现合法的请求
* 200：请求被正常处理
* 204：请求被受理但没有资源可以返回
* 206：客户端只是请求资源的一部分，服务器只对请求的部分资源执行GET方法，相应报文中通过Content-Range指定范围的资源。
* 301：永久性重定向
* 302：临时重定向
* 303：与302状态码有相似功能，只是它希望客户端在请求一个URI的时候，能通过GET方法重定向到另一个URI上
* 304：发送附带条件的请求时，条件不满足时返回，与重定向无关
* 307：临时重定向，与302类似，只是强制要求使用POST方法
* 400：请求报文语法有误，服务器无法识别
* 401：请求需要认证
* 403：请求的对应资源禁止被访问
* 404：服务器无法找到对应资源
* 500：服务器内部错误
* 503：服务器正忙


### http的状态码中，499是什么?如何出现499，如何排查跟解决

499对应的是 `“client has closed connection”`，客户端请求等待链接已经关闭，这很有可能是因为服务器端处理的时间过长，客户端等得“不耐烦”了。还有一种原因是两次提交post过快就会出现499。

解决方法：

* 前端将timeout最大等待时间设置大一些
* nginx上配置`proxy_ignore_client_abort on`;


### http的缺点

* 通信使用明文不加密，内容可能被窃听
* 不验证通信方身份，可能遭到伪装
* 无法验证报文完整性，可能被篡改


### http与https的区别

* HTTP 的URL 以http:// 开头，而HTTPS 的URL 以https:// 开头
* HTTP 是不安全的，而 HTTPS 是安全的
* HTTP 标准端口是80 ，而 HTTPS 的标准端口是443
* 在OSI 网络模型中，HTTP工作于应用层，而HTTPS 的安全传输机制工作在传输层
* HTTP 无法加密，而HTTPS 对传输的数据进行加密
* HTTP无需证书，而HTTPS 需要CA机构wosign的颁发的SSL证书


### 什么是Http协议无状态协议?怎么解决Http协议无状态协议?

无状态协议对于事务处理没有记忆能力。也就是说，当客户端一次HTTP请求完成以后，客户端再发送一次HTTP请求，HTTP并不知道当前客户端是一个”老用户“。

可以使用Cookie来解决无状态的问题，Cookie就相当于一个通行证，第一次访问的时候给客户端发送一个Cookie，当客户端再次来的时候，拿着Cookie(通行证)，那么服务器就知道这个是”老用户“。


### URI和URL的区别

URI，是uniform resource identifier，统一资源标识符，用来唯一的标识一个资源。

Web上可用的每种资源如HTML文档、图像、视频片段、程序等都是一个来URI来定位的

URI一般由三部组成：

* 访问资源的命名机制
* 存放资源的主机名
* 资源自身的名称，由路径表示，着重强调于资源。

URL是uniform resource locator，统一资源定位器，它是一种具体的URI，即URL可以用来标识一个资源，而且还指明了如何locate这个资源。

URL是Internet上用来描述信息资源的字符串，主要用在各种WWW客户程序和服务器程序上，特别是著名的Mosaic。
采用URL可以用一种统一的格式来描述各种信息资源，包括文件、服务器的地址和目录等。

URL一般由三部组成：

* 协议(或称为服务方式)
* 存有该资源的主机IP地址(有时也包括端口号)
* 主机资源的具体地址。如目录和文件名等


### 常用的HTTP方法有哪些？

* GET： 用于请求访问已经被URI（统一资源标识符）识别的资源，可以通过URL传参给服务器
* POST：用于传输信息给服务器，主要功能与GET方法类似，但一般推荐使用POST方式。
* PUT： 传输文件，报文主体中包含文件内容，保存到对应URI位置。
* HEAD： 获得报文首部，与GET方法类似，只是不返回报文主体，一般用于验证URI是否有效。
* DELETE：删除文件，与PUT方法相反，删除对应URI位置的文件。
* OPTIONS：查询相应URI支持的HTTP方法。


### GET方法与POST方法的区别

* get重点在从服务器上获取资源，post重点在向服务器发送数据；
* get传输数据是通过URL请求，以field（字段）= value的形式，置于URL后，并用"?"连接，多个请求数据间用"&"连接，如`http://127.0.0.1/Test/login.action?name=admin&password=admin`，这个过程用户是可见的；post传输数据通过Http的post机制，将字段与对应值封存在请求实体中发送给服务器，这个过程对用户是不可见的；
* Get传输的数据量小，因为受URL长度限制，但效率较高；Post可以传输大量数据，所以上传文件时只能用Post方式
* get是不安全的，因为URL是可见的，可能会泄露私密信息，如密码等；post较get安全性较高
* get方式只能支持ASCII字符，向服务器传的中文字符可能会乱码；post支持标准字符集，可以正确传递中文字符。


### HTTP请求报文与响应报文格式

请求报文包含四部分：

* 请求行：包含请求方法、URI、HTTP版本信息
* 请求首部字段
* 请求内容实体
* 空行

响应报文包含四部分：

* 状态行：包含HTTP版本、状态码、状态码的原因短语
* 响应首部字段
* 响应内容实体
* 空行


### 常见HTTP首部字段

* 通用首部字段（请求报文与响应报文都会使用的首部字段）

    * Date：创建报文时间
    * Connection：连接的管理
    * Cache-Control：缓存的控制
    * Transfer-Encoding：报文主体的传输编码方式


* 请求首部字段（请求报文会使用的首部字段）

    * Host：请求资源所在服务器
    * Accept：可处理的媒体类型
    * Accept-Charset：可接收的字符集
    * Accept-Encoding：可接受的内容编码
    * Accept-Language：可接受的自然语言


* 响应首部字段（响应报文会使用的首部字段）

    * Accept-Ranges：可接受的字节范围
    * Location：令客户端重新定向到的URI
    * Server：HTTP服务器的安装信息


* 实体首部字段（请求报文与响应报文的的实体部分使用的首部字段）

    * Allow：资源可支持的HTTP方法
    * Content-Type：实体主类的类型
    * Content-Encoding：实体主体适用的编码方式
    * Content-Language：实体主体的自然语言
    * Content-Length：实体主体的的字节数
    * Content-Range：实体主体的位置范围，一般用于发出部分请求时使用


### HTTP优化方案

* TCP复用：TCP连接复用是将多个客户端的HTTP请求复用到一个服务器端TCP连接上，而HTTP复用则是一个客户端的多个HTTP请求通过一个TCP连接进行处理。前者是负载均衡设备的独特功能；而后者是HTTP 1.1协议所支持的新功能，目前被大多数浏览器所支持。
* 内容缓存：将经常用到的内容进行缓存起来，那么客户端就可以直接在内存中获取相应的数据了。
* 压缩：将文本数据进行压缩，减少带宽
* SSL加速（SSL Acceleration）：使用SSL协议对HTTP协议进行加密，在通道内加密并加速
* TCP缓冲：通过采用TCP缓冲技术，可以提高服务器端响应时间和处理效率，减少由于通信链路问题给服务器造成的连接负担。

详情参考： 

* [利用负载均衡优化和加速HTTP应用](https://blog.51cto.com/virtualadc/580832)
* [利用HTTP Cache来优化网站](http://www.cnblogs.com/cocowool/archive/2011/08/22/2149929.html)


### 一次完整的HTTP请求所经历的7个步骤

HTTP通信机制是在一次完整的HTTP通信过程中，Web浏览器与Web服务器之间将完成下列7个步骤：

* 建立TCP连接

	在HTTP工作开始之前，Web浏览器首先要通过网络与Web服务器建立连接，该连接是通过TCP来完成的，该协议与IP协议共同构建 Internet，即著名的TCP/IP协议族，因此Internet又被称作是TCP/IP网络。HTTP是比TCP更高层次的应用层协议，根据规则， 只有低层协议建立之后才能，才能进行更层协议的连接，因此，首先要建立TCP连接，一般TCP连接的端口号是80。

* Web浏览器向Web服务器发送请求行

	一旦建立了TCP连接，Web浏览器就会向Web服务器发送请求命令。例如：GET /test HTTP/1.1。

* Web浏览器发送请求头

	浏览器发送其请求命令之后，还要以头信息的形式向Web服务器发送一些别的信息，之后浏览器发送了一空白行来通知服务器，它已经结束了该头信息的发送。

* Web服务器应答

	客户机向服务器发出请求后，服务器会客户机回送应答， HTTP/1.1 200 OK ，应答的第一部分是协议的版本号和应答状态码。

* Web服务器发送应答头

	正如客户端会随同请求发送关于自身的信息一样，服务器也会随同应答向用户发送关于它自己的数据及被请求的文档。

* Web服务器向浏览器发送数据

	Web服务器向浏览器发送头信息后，它会发送一个空白行来表示头信息的发送到此为结束，接着，它就以Content-Type应答头信息所描述的格式发送用户所请求的实际数据。

* Web服务器关闭TCP连接

	一般情况下，一旦Web服务器向浏览器发送了请求数据，它就要关闭TCP连接，然后如果浏览器或者服务器在其头信息加入了这行代码：`Connection:keep-alive`, TCP连接在发送后将仍然保持打开状态，于是，浏览器可以继续通过相同的连接发送请求。保持连接节省了为每个请求建立新连接所需的时间，还节约了网络带宽。


建立TCP连接->发送请求行->发送请求头->（到达服务器）发送状态行->发送响应头->发送响应数据->断TCP连接


### HTTP1.1版本新特性

* 默认持久连接节省通信量，只要客户端服务端任意一端没有明确提出断开TCP连接，就一直保持连接，可以发送多次HTTP请求
* 管线化，客户端可以同时发出多个HTTP请求，而不用一个个等待响应
* 断点续传, 实际上就是利用HTTP消息头使用分块传输编码，将实体主体分块传输。


### HTTP长连接、短连接

在HTTP/1.0中默认使用短连接。也就是说，客户端和服务器每进行一次HTTP操作，就建立一次连接，任务结束就中断连接。当客户端浏览器访问的某个HTML或其他类型的Web页中包含有其他的Web资源（如JavaScript文件、图像文件、CSS文件等），每遇到这样一个Web资源，浏览器就会重新建立一个HTTP会话。

而从HTTP/1.1起，默认使用长连接，用以保持连接特性。使用长连接的HTTP协议，会在响应头加入这行代码：

```
Connection:keep-alive
```

在使用长连接的情况下，当一个网页打开完成后，客户端和服务器之间用于传输HTTP数据的TCP连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接。Keep-Alive不会永久保持连接，它有一个保持时间，可以在不同的服务器软件（如Apache）中设定这个时间。实现长连接需要客户端和服务端都支持长连接。

**HTTP协议的长连接和短连接，实质上是TCP协议的长连接和短连接。**


### 为什么HTTP协议要基于TCP来实现？

目前在Internet中所有的传输都是通过TCP/IP进行的，HTTP协议作为TCP/IP模型中应用层的协议也不例外，TCP是一个端到端的可靠的面向连接的协议，所以HTTP基于传输层TCP协议不用担心数据的传输的各种问题。


### https工作原理

* 客户端发起HTTPS请求

	这个没什么好说的，就是用户在浏览器里输入一个https网址，然后连接到server的443端口。

* 服务端的配置

	采用HTTPS协议的服务器必须要有一套数字证书，可以自己制作，也可以向组织申请。区别就是自己颁发的证书需要客户端验证通过，才可以继续访问，而使用受信任的公司申请的证书则不会弹出提示页面(startssl就是个不错的选择，有1年的免费服务)。这套证书其实就是一对公钥和私钥。如果对公钥和私钥不太理解，可以想象成一把钥匙和一个锁头，只是全世界只有你一个人有这把钥匙，你可以把锁头给别人，别人可以用这个锁把重要的东西锁起来，然后发给你，因为只有你一个人有这把钥匙，所以只有你才能看到被这把锁锁起来的东西。

* 传送证书

	这个证书其实就是公钥，只是包含了很多信息，如证书的颁发机构，过期时间等等。

* 客户端解析证书

	这部分工作是有客户端的TLS来完成的，首先会验证公钥是否有效，比如颁发机构，过期时间等等，如果发现异常，则会弹出一个警告框，提示证书存在问题。如果证书没有问题，那么就生成一个随即值。然后用证书对该随机值进行加密。就好像上面说的，把随机值用锁头锁起来，这样除非有钥匙，不然看不到被锁住的内容。

* 传送加密信息

	这部分传送的是用证书加密后的随机值，目的就是让服务端得到这个随机值，以后客户端和服务端的通信就可以通过这个随机值来进行加密解密了。

* 服务段解密信息

	服务端用私钥解密后，得到了客户端传过来的随机值(私钥)，然后把内容通过该值进行对称加密。所谓对称加密就是，将信息和私钥通过某种算法混合在一起，这样除非知道私钥，不然无法获取内容，而正好客户端和服务端都知道这个私钥，所以只要加密算法够彪悍，私钥够复杂，数据就够安全。

* 传输加密后的信息

	这部分信息是服务段用私钥加密后的信息，可以在客户端被还原

* 客户端解密信息

	客户端用之前生成的私钥解密服务段传过来的信息，于是获取了解密后的内容。整个过程第三方即使监听到了数据，也束手无策。


### TCP的三次握手和四次挥手,两次握手可以吗？

TCP的三次握手：

* 客户端发送一个SYN报文请求连接，变为SYN_SEND状态
* 服务端接收到客户端发送SYN包，进行确认过后，发送ACK报文，变为SYN_RECV状态
* 客户端接收到服务端的SYN和ACK报文后，发送ACK包进行确认，然后客户端和服务端都变成ESTABLISHED状态

TCP的四次挥手：

* 客户端没有数据要发送了，请求关闭连接，发送一个FIN报文，并进入FIN_WAIT_1状态
* 服务端接收到FIN报文后，发送ACK报文，然后进入CLOSE_WAIT状态；客户端接收到ACK报文后，进入FIN_WAIT_2状态
* 服务端判断是否有数据发送给客户端，如果有的话，就将数据发送给客户端，再发送FIN报文；没有的话就直接发送FIN报文，请求关闭连接，然后进入LAST_ACK状态；
* 客户端接收到服务端的FIN报文后，发送ACK报文，然后客户端进入TIME_WAIT状态；服务端接收到ACK报文后，关闭连接，变为CLOSED状态，客户端在2MSL后依然没有收到回复，也可以关闭连接了。
 
两次握手可以吗？

不可以，三次握手主要是防止已经过期的请求再次连接到服务端而占用资源造成浪费。如果是两次握手的话，假设主机A在发送第一次请求时，由于网络滞留的问题卡住了，很久后没有收到主机B的确认信息，于是又发送了第二次请求。过了一段时间后，第一个请求到达了主机B，主机B以为是一次新的请求，就返回确认信息，但是由于没有第三次握手，只要主机B发出确认信息，就会连接，这个时候主机B一直等待着主机A发送信息，就会造成资源浪费。


### TCP和UDP的区别是什么？

* 连接方面：TCP是面向连接的，而UDP是无连接的，即UDP在传输数据之前不需要像TCP那样3次握手建立连接
* 可靠性：TCP比UDP更可靠，TCP可以保证不丢包，会按照顺序传输数据，这也是导致
* 资源消耗：TCP对系统资源要求比较高，并且消耗资源比较大；UDP要求不高，但是在网络质量不好的情况下比较容易丢包，消耗资源相对比较小
* 适用场景：TCP适用于HTTP，FTP以及邮件传输等等；而UDP比较适合于语音，视频等
* 速度问题：TCP传输速度比较慢，效率低，在握手和挥手的过程中会占用很多时间；UDP传输速度比较快，由于是无连接的，只有传输数据的过程
* 安全性：安全性和可靠性是不同的概念，由于TCP的机制比较多，更容易受到攻击；UDP相对来说就比较安全，但是也不能避免受到攻击
* 连接形式：TCP是只能一对一的发送，而UDP可以是一对一，一对多，多对多


### SSL有几次握手？具体过程是怎样的？

SSL有4次握手，握手过程为：

* 客户端请求SSL连接
* 服务端发送包含公钥的证书
* 客户端使用公钥加密对称秘钥并发送给服务端
* 服务端使用私钥解密对称秘钥