## Mysql面试题整理


* [什么是数据库事务？如果没有事物会有什么后果？事务的特性是什么？](#什么是数据库事务如果没有事物会有什么后果事务的特性是什么)
* [什么是脏读？幻读？不可重复读？](#什么是脏读幻读不可重复读)
* [什么是事务的隔离级别？Mysql的默认隔离级别是？](#什么是事务的隔离级别Mysql的默认隔离级别是)
* [事物隔离是怎么实现的？](#事物隔离是怎么实现的)
* [有哪些锁？分别介绍下](#有哪些锁分别介绍下)
* [ 什么是死锁？怎么解决？](#什么是死锁怎么解决)
* [什么是乐观锁？悲观锁？实现方式？](#什么是乐观锁悲观锁实现方式)
* [什么是数据库连接池？](#什么是数据库连接池)


### 什么是数据库事务？如果没有事物会有什么后果？事务的特性是什么？

事务是指作为单个逻辑工作单元执行的一系列操作，可以被看作一个单元的一系列SQL语句的集合。要么完全地执行，要么完全地不执行。

如果不对数据库进行并发控制，可能会产生 脏读、非重复读、幻像读、丢失修改的异常情况。


事务的特性（ACID）

A, atomacity 原子性
事务必须是原子工作单元；对于其数据修改，要么全都执行，要么全都不执行。通常，与某个事务关联的操作具有共同的目标，并且是相互依赖的。如果系统只执行这些操作的一个子集，则可能会破坏事务的总体目标。原子性消除了系统处理操作子集的可能性。

C, consistency 一致性
事务将数据库从一种一致状态转变为下一种一致状态。也就是说，事务在完成时，必须使所有的数据都保持一致状态（各种 constraint 不被破坏）。

I, isolation 隔离性
由并发事务所作的修改必须与任何其它并发事务所作的修改隔离。事务查看数据时数据所处的状态，要么是另一并发事务修改它之前的状态，要么是另一事务修改它之后的状态，事务不会查看中间状态的数据。换句话说，一个事务的影响在该事务提交前对其他事务都不可见。

D, durability 持久性
事务完成之后，它对于系统的影响是永久性的。该修改即使出现致命的系统故障也将一直保持。


### 什么是脏读？幻读？不可重复读？

* 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
* 不可重复读：事务 A 多次读取同一数据，事务 B 在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
* 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。


### 什么是事务的隔离级别？Mysql的默认隔离级别是？

有四种事务隔离级别：

* Read uncommitted 读未提交，顾名思义，就是一个事务可以读取另一个未提交事务的数据。
* Read committed 读提交，顾名思义，就是一个事务要等另一个事务提交后才能读取数据。
* Repeatable read 重复读，就是在开始读取数据（事务开启）时，不再允许修改操作
* Serializable 串行读，是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。

Mysql的默认隔离级别是Repeatable read。

### 事物隔离是怎么实现的？

是基于锁实现的.

### 有哪些锁？分别介绍下

在DBMS中，可以按照锁的粒度把数据库锁分为行级锁(INNODB引擎)、表级锁(MYISAM引擎)和页级锁(BDB引擎 )。

**行级锁:**

行级锁是Mysql中锁定粒度最细的一种锁，表示只针对当前操作的行进行加锁。行级锁能大大减少数据库操作的冲突。其加锁粒度最小，但加锁的开销也最大。行级锁分为共享锁 和 排他锁。

特点：
开销大，加锁慢；会出现死锁；锁定粒度最小，发生锁冲突的概率最低，并发度也最高。

**表级锁:**

表级锁是MySQL中锁定粒度最大的一种锁，表示对当前操作的整张表加锁，它实现简单，资源消耗较少，被大部分MySQL引擎支持。最常使用的MYISAM与INNODB都支持表级锁定。表级锁定分为表共享读锁（共享锁）与表独占写锁（排他锁）。

特点：开销小，加锁快；不会出现死锁；锁定粒度大，发出锁冲突的概率最高，并发度最低。

**页级锁:**

页级锁是MySQL中锁定粒度介于行级锁和表级锁中间的一种锁。表级锁速度快，但冲突多，行级冲突少，但速度慢。所以取了折衷的页级，一次锁定相邻的一组记录。

特点：开销和加锁时间界于表锁和行锁之间；会出现死锁；锁定粒度界于表锁和行锁之间，并发度一般
	
### 什么是死锁？怎么解决？

死锁是指两个或多个事务在同一资源上相互占用，并请求锁定对方的资源，从而导致恶性循环的现象。

常见的解决死锁的方法

* 如果不同程序会并发存取多个表，尽量约定以相同的顺序访问表，可以大大降低死锁机会。
* 在同一个事务中，尽可能做到一次锁定所需要的所有资源，减少死锁产生概率；
* 对于非常容易产生死锁的业务部分，可以尝试使用升级锁定颗粒度，通过表级锁定来减少死锁产生的概率；

如果业务处理不好可以用分布式事务锁或者使用乐观锁


### 什么是乐观锁？悲观锁？实现方式？

**悲观锁：**

悲观锁指对数据被意外修改持保守态度，依赖数据库原生支持的锁机制来保证当前事务处理的安全性，防止其他并发事务对目标数据的破坏或破坏其他并发事务数据，将在事务开始执行前或执行中申请锁定，执行完后再释放锁定。这对于长事务来讲，可能会严重影响系统的并发处理能力。 自带的数据库事务就是典型的悲观锁。

**乐观锁：**

乐观锁（Optimistic Lock），顾名思义，就是很乐观，每次去拿数据的时候都认为别人不会修改，所以不会上锁，但是在提交更新的时候会判断一下在此期间别人有没有去更新这个数据。乐观锁适用于读多写少的应用场景，这样可以提高吞吐量。一般是加一个版本号字段 每次更新时候比较版本号。


### 什么是数据库连接池？

连接在sql生命周期里面发挥着重大作用，但频繁的创建和销毁，非常浪费系统资源。由于数据库更适合长连接，也就有个连接池，能对连接复用，维护连接对象、分配、管理、释放，也可以避免创建大量的连接对DB引发的各种问题；另外通过请求排队，也缓解对DB的冲击。

